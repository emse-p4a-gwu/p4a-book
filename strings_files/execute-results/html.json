{
  "hash": "71455b256ed83f58c788edf439f09385",
  "result": {
    "markdown": "# Strings {#sec-strings}\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nhere() starts at /Users/jhelvy/gh/teaching/P4A/p4a-book\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.0      ✔ stringr 1.4.1 \n✔ readr   2.1.2      ✔ forcats 0.5.1 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\n> ### Learning Objectives\n>\n> * Understand basic functions in the `stringr` library for working with character data.\n> * Understand how to deal with whitespace.\n> * Understand how to split strings.\n> * Understand how to match strings.\n>\n> ### Suggested readings\n>\n> * [Chapter 14](https://r4ds.had.co.nz/strings.html) of \"R for Data Science\", by Garrett Grolemund and Hadley Wickham\n> * [Introduction to `stringr` vignette](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)\n> * The [`stringr` package documentation](https://stringr.tidyverse.org/)\n\n---\n\nA \"string\" is the generic word for character type variables. Base R has many built-in functions for working with strings, but they are often difficult to remember and unintuitive to use. Fortunately, the wonderful folks over at the [tidyverse](https://www.tidyverse.org/) developed a lovely package called [`\"stringr\"`](https://stringr.tidyverse.org/), which makes working with strings a lot nicer.\n\nBefore going any further, make sure you install the `stringr` package and load it before trying to use any of the functions in this lesson:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninstall.packages(\"stringr\")\nlibrary(stringr)\n```\n:::\n\n\n---\n\n# Making a string\n\nYou can create strings with either single quotes (`''`) or double quotes (`\"\"`). There is no difference in behavior.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncat(\"This is a string\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> This is a string\n```\n:::\n\n```{.r .cell-code}\ncat('This is a string')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> This is a string\n```\n:::\n:::\n\n\nIf you have a string that contains a `'` symbol, use double quotes:\nUse them where it makes sense, e.g.:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncat(\"It's a boy!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> It's a boy!\n```\n:::\n:::\n\n\nLikewise, if you have a string that contains a `\"` symbol, use single quotes:\nUse them where it makes sense, e.g.:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncat('I said, \"Hi!\"')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> I said, \"Hi!\"\n```\n:::\n:::\n\n\nBut what if you have a string that has both single and double quotes, like this: `It's nice to say, \"Hi!\"`\n\nIn this case, you have to \"escape\" the quotes by using the `\\` symbol:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncat(\"It's nice to say, \\\"Hi!\\\"\") # Double quotes escaped\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> It's nice to say, \"Hi!\"\n```\n:::\n\n```{.r .cell-code}\ncat('It\\'s nice to say, \"Hi!\"') # Single quote escaped\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> It's nice to say, \"Hi!\"\n```\n:::\n:::\n\n\nEscaping can be used for a lot of different string literals, such as starting a new line, adding a tab space, and even entering the `\\` symbol itself:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncat('New line:', 'This\\nthat')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> New line: This\n#> that\n```\n:::\n\n```{.r .cell-code}\ncat('Tab space:', 'This\\tthat')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> Tab space: This\tthat\n```\n:::\n\n```{.r .cell-code}\ncat('Backslash:', 'This\\\\that')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> Backslash: This\\that\n```\n:::\n:::\n\n\nBeware that the printed representation of a string in the R console is not the same as string itself, because the printed representation shows the escapes. To see the raw contents of the string, use `cat()` or `writeLines()`.\n\n# String constants\n\nR has a small number of built-in string constants: `LETTERS`, `letters`, `month.abb`, and `month.name`. These are common values stored in variables with convenient names:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nLETTERS\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n#> [20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n```\n:::\n\n```{.r .cell-code}\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n#> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n:::\n\n```{.r .cell-code}\nmonth.abb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n```\n:::\n\n```{.r .cell-code}\nmonth.name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n#>  [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\"\n```\n:::\n:::\n\n\nIf you assign-over one of these constants, you can always retrieve the constant by putting the `base::` prefix in front:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nletters <- 7\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 7\n```\n:::\n\n```{.r .cell-code}\nletters <- base::letters\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n#> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n:::\n:::\n\n\nIn addition to the Base R constants, the `stringr` library also comes with three constants: `words`, `sentences`, and `fruit`. These are much longer, so let's use the `head()` function to just preview the first 6 elements in each:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"a\"        \"able\"     \"about\"    \"absolute\" \"accept\"   \"account\"\n```\n:::\n\n```{.r .cell-code}\nhead(sentences)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"The birch canoe slid on the smooth planks.\" \n#> [2] \"Glue the sheet to the dark blue background.\"\n#> [3] \"It's easy to tell the depth of a well.\"     \n#> [4] \"These days a chicken leg is a rare dish.\"   \n#> [5] \"Rice is often served in round bowls.\"       \n#> [6] \"The juice of lemons makes fine punch.\"\n```\n:::\n\n```{.r .cell-code}\nhead(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"apple\"       \"apricot\"     \"avocado\"     \"banana\"      \"bell pepper\"\n#> [6] \"bilberry\"\n```\n:::\n:::\n\n\n# Basic `\"stringr\"` Operations\n\nMost `stringr` functions start with `str_`, which makes it particularly easy to remember. The following table contains the main `stringr` functions we'll cover:\n\n|Function         |  Description                            |\n|:----------------|:----------------------------------------|\n|`str_to_lower()` | converts string to lower case           |\n|`str_to_upper()` | converts string to upper case           |\n|`str_to_title()` | converts string to title case           |\n|`str_length()`   | number of characters                    |\n|`str_sub()`      | extracts substrings                     |\n|`str_locate()`   | returns indices of substrings           |\n|`str_dup()`      | duplicates characters                   |\n|`str_trim()`     | removes leading and trailing whitespace |\n|`str_pad()`      | pads a string                           |\n|`str_c()`        | string concatenation                    |\n|`str_split()`    | split a string into a vector            |\n|`str_sort()`     | sort a string alphabetically            |\n|`str_order()`    | get the order of a sorted string        |\n|`str_detect()`   | match a string in another string        |\n|`str_replace()`  | replace a string in another string      |\n\nThe common `str_` prefix is particularly useful in RStudio, because typing `str_` will trigger autocomplete, allowing you to see all `stringr` functions:\n\n![](images/stringr-autocomplete.png){ width=600 }\n\n## Case conversion\n\nYou can convert whole strings to lower-case, upper-case, and title-case using some conveniently-named functions:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- \"Want to hear a joke about paper? Never mind, it's tearable.\"\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_to_lower(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"want to hear a joke about paper? never mind, it's tearable.\"\n```\n:::\n\n```{.r .cell-code}\nstr_to_upper(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"WANT TO HEAR A JOKE ABOUT PAPER? NEVER MIND, IT'S TEARABLE.\"\n```\n:::\n\n```{.r .cell-code}\nstr_to_title(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"Want To Hear A Joke About Paper? Never Mind, It's Tearable.\"\n```\n:::\n:::\n\n\n**Sidenote**: Notice that `str_to_title()` makes every first letter in each word upper case. This is slightly different from what you might expect, since most \"titles\" don't make articles like \"a\" and \"the\" upper case. An alternative function that makes a more appropriate title case is the `toTitleCase()` function from the **tools** library:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tools)\ntoTitleCase(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"Want to Hear a Joke About Paper? Never Mind, It's Tearable.\"\n```\n:::\n:::\n\n\n## Get the number of characters in a string\n\nIf you want to find how long a string is (i.e. how many characters it contains), the `length()` function won't work:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlength(\"hello world\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 1\n```\n:::\n:::\n\n\nThat's be `length()` returns how many elements are in a _vector_ (in the above case, there's just one element). Instead, you should use `str_length()`:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_length(\"hello world\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 11\n```\n:::\n:::\n\n\nNote that the space character has a length:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_length(\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 1\n```\n:::\n:::\n\n\nAlso note that the \"empty\" string (`\"\"`) has no length:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_length(\"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0\n```\n:::\n:::\n\n\n## Access characters by their index\n\nYou can access individual character using `str_sub()`. It takes three arguments: a string (or character vector), a `start` position, and an `end` position. Either position can either be a positive integer, which counts from the left, or a negative integer which counts from the right. The positions are inclusive, and if longer than the string, will be silently truncated.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- \"Apple\"\nstr_sub(x, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"App\"\n```\n:::\n\n```{.r .cell-code}\n# Negative numbers count backwards from the end\nstr_sub(x, -3, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"ple\"\n```\n:::\n:::\n\n\nNote that `str_sub()` won't fail if the string is too short: it will just return as much as possible:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_sub(\"Apple\", 1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"Apple\"\n```\n:::\n:::\n\n\nYou can also use the assignment form of `str_sub()` to modify specific elements in strings:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 'abcdef'\nstr_sub(x, 1, 3) <- 'ABC'\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"ABCdef\"\n```\n:::\n:::\n\n\n## Get the indices of substrings\n\nIf you want to know the start and end indices of a particular substring, use `str_locate()`. This is a helpful function to use in combination with `str_sub()` so you don't have to count the characters to find a substring.\n\nFor example, let's say I want to extract the substring `\"Good\"` from the following string:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 'thisIsGoodPractice'\n```\n:::\n\n\nI could first use `str_locate()` to get the start and end indices:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nindices <- str_locate(x, 'Good')\nindices\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>      start end\n#> [1,]     7  10\n```\n:::\n:::\n\n\nNow that I have the start and end locations, I can use them within `str_sub()`:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_sub(x, indices[1], indices[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"Good\"\n```\n:::\n:::\n\n\n## Repeat a string\n\nTo duplicate strings, use `str_dup()`:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_dup(\"hola\", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"holaholahola\"\n```\n:::\n:::\n\n\nNote the difference with `rep()` (which returns a vector):\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrep(\"hola\", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"hola\" \"hola\" \"hola\"\n```\n:::\n:::\n\n\n## Removing \"whitespace\"\n\n`str_trim()` removes leading and trailing whitespace:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- \"         aStringWithSpace        \"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"         aStringWithSpace        \"\n```\n:::\n\n```{.r .cell-code}\nstr_trim(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"aStringWithSpace\"\n```\n:::\n:::\n\n\nBy default, `str_trim()` removes whitespace on both sides, but you can specify a single side:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_trim(x, side = \"left\") # Only trim left side\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"aStringWithSpace        \"\n```\n:::\n\n```{.r .cell-code}\nstr_trim(x, side = \"right\") # Only trim right side\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"         aStringWithSpace\"\n```\n:::\n:::\n\n\n## Add whitespace (or other characters)\n\n`str_pad()` pads a string to a fixed length by adding extra whitespace on\nthe left, right, or both sides. Note that the `width` argument is the length of the _final_ string (not the length of the added padding):\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- \"hello\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"hello\"\n```\n:::\n\n```{.r .cell-code}\nstr_pad(x, width = 10) # Inserts pad on left by default\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"     hello\"\n```\n:::\n\n```{.r .cell-code}\nstr_pad(x, width = 10, side = \"both\") # Pad both sides\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"  hello   \"\n```\n:::\n:::\n\n\nYou can pad with other characters by using the `pad` argument:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_pad(x, 10, side=\"both\", pad='-')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"--hello---\"\n```\n:::\n:::\n\n\nAlso, `str_pad()` will never make a string shorter:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_pad(x, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"hello\"\n```\n:::\n:::\n\n\n## Combine strings into one string\n\nTo combine two or more strings, use `str_c()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_c('x', 'y', 'z')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"xyz\"\n```\n:::\n:::\n\n\nUse the `sep` argument to control how they're separated:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_c('x', 'y', 'z', sep = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"x-y-z\"\n```\n:::\n:::\n\n\nYou can also concatenate a _vector_ of strings by adding the `collapse` argument to the `str_c()` function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_c(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n#> [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n:::\n\n```{.r .cell-code}\nstr_c(letters, collapse = '')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"abcdefghijklmnopqrstuvwxyz\"\n```\n:::\n\n```{.r .cell-code}\nstr_c(letters, collapse = '-')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z\"\n```\n:::\n:::\n\n\nObjects of length `0` are silently dropped. This is particularly useful in conjunction with `if` statements:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprintGreeting <- function(name, timeOfDay, isBirthday) {\n    greeting <- str_c(\n        \"Good \", timeOfDay, \" \", name,\n            if (isBirthday) {\n                \", and HAPPY BIRTHDAY!\"\n            } else {\n                '.'\n            }\n        )\n    cat(greeting)\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprintGreeting('John', 'morning', isBirthday = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> Good morning John.\n```\n:::\n\n```{.r .cell-code}\nprintGreeting('John', 'morning', isBirthday = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> Good morning John, and HAPPY BIRTHDAY!\n```\n:::\n:::\n\n\n## Split a string into multiple strings\n\nUse `str_split()` to split a string up into pieces along a particular delimiter.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstring <- 'This string has spaces-and-dashes'\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_split(string, \" \") # Split on the spaces\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [[1]]\n#> [1] \"This\"              \"string\"            \"has\"              \n#> [4] \"spaces-and-dashes\"\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_split(string, \"-\") # Split on the dashes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [[1]]\n#> [1] \"This string has spaces\" \"and\"                    \"dashes\"\n```\n:::\n:::\n\n\nBy default, `str_split()` returns a `list` (another R data structure) of vectors. Each item in the list is a vector of strings. In the above cases, we gave `str_split()` a single string, so there is only one item in the returned list. In these cases, the easiest way to access the resulting vector of split strings is to use the double bracket `[[]]` operator to access the first list item:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_split(string, \" \") # Returns a list of vectors\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [[1]]\n#> [1] \"This\"              \"string\"            \"has\"              \n#> [4] \"spaces-and-dashes\"\n```\n:::\n\n```{.r .cell-code}\nstr_split(string, \" \")[[1]] # Returns the first vector in the list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"This\"              \"string\"            \"has\"              \n#> [4] \"spaces-and-dashes\"\n```\n:::\n:::\n\n\nIf you give `str_split()` a vector of strings, it will return a list of length equal to the number of elements in the vector:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c('babble', 'scrabblebabble')\nstr_split(x, 'bb') # Returns a list with two elements (each a vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [[1]]\n#> [1] \"ba\" \"le\"\n#> \n#> [[2]]\n#> [1] \"scra\" \"leba\" \"le\"\n```\n:::\n:::\n\n\nA particularly useful string split is to split on the empty string (`\"\"`), which breaks a string up into its individual characters:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_split(string, \"\")[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"T\" \"h\" \"i\" \"s\" \" \" \"s\" \"t\" \"r\" \"i\" \"n\" \"g\" \" \" \"h\" \"a\" \"s\" \" \" \"s\" \"p\" \"a\"\n#> [20] \"c\" \"e\" \"s\" \"-\" \"a\" \"n\" \"d\" \"-\" \"d\" \"a\" \"s\" \"h\" \"e\" \"s\"\n```\n:::\n:::\n\n\n## Word extraction with `word()`\n\nThe `word()` function that another way to split up a longer string. It is designed to extract words from a sentence. You use `word()` by by passing it a `string` together with a `start` position of the first word to extract and an `end` position of the last word to extract. By default, the separator `sep` used between words is a single space. Here's some examples:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsentence <- c(\"Be the change you want to be\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Extract first word\nword(sentence, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"Be\"\n```\n:::\n\n```{.r .cell-code}\n# Extract second word\nword(sentence, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"the\"\n```\n:::\n\n```{.r .cell-code}\n# Extract last word\nword(sentence, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"be\"\n```\n:::\n\n```{.r .cell-code}\n# Extract all but the first word\nword(sentence, 2, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"the change you want to be\"\n```\n:::\n:::\n\n\n## Alphabetically sorting string vectors\n\nYou can sort a vector of strings alphabetically using `str_sort()` and `str_order()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c('Y', 'M', 'C', 'A')\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_sort(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"A\" \"C\" \"M\" \"Y\"\n```\n:::\n\n```{.r .cell-code}\nstr_sort(x, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"Y\" \"M\" \"C\" \"A\"\n```\n:::\n\n```{.r .cell-code}\nstr_order(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 4 3 2 1\n```\n:::\n\n```{.r .cell-code}\nx[str_order(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"A\" \"C\" \"M\" \"Y\"\n```\n:::\n:::\n\n\n## Detect if a pattern is in a string\n\nTo determine if a character vector matches a pattern, use `str_detect()`. It returns a logical vector the same length as the input:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntenFruit <- fruit[1:10]\ntenFruit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"apple\"        \"apricot\"      \"avocado\"      \"banana\"       \"bell pepper\" \n#>  [6] \"bilberry\"     \"blackberry\"   \"blackcurrant\" \"blood orange\" \"blueberry\"\n```\n:::\n\n```{.r .cell-code}\nstr_detect(tenFruit, \"berry\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n```\n:::\n:::\n\n\nRemember that when you use a logical vector in a numeric context, `FALSE` becomes `0` and `TRUE` becomes `1`. That makes `sum()` and `mean()` useful if you want to answer questions about matches across a vector:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# How many fruit in tenFruit contain the string \"berry\"?\n# How many words in the stringr \"words\" vector contain the letter \"a\"?\nsum(str_detect(tenFruit, \"berry\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 3\n```\n:::\n\n```{.r .cell-code}\n# What proportion contain the string \"berry\"?\nmean(str_detect(tenFruit, \"berry\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 0.3\n```\n:::\n:::\n\n\nIf you want to _count_ the number of times a particular string pattern appears, use `str_count`:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(\"apple\", \"banana\", \"pear\")\nstr_count(x, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] 1 3 1\n```\n:::\n:::\n\n\n## Anchors\n\nBy default, `str_detect()` will match any part of a string. But it's often useful to _anchor_ the matching condition so that it matches from the start or end of the string. You can use:\n\n- `^` to match the _start_ of the string.\n- `$` to match the _end_ of the string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Which fruit start with \"a\"?\nstr_detect(tenFruit, \"^a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n# Which fruit end with \"y\"?\nstr_detect(tenFruit, \"e$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n```\n:::\n:::\n\n\nTo remember which is which, try this mnemonic:\n\n> If you _start_ with power (`^`), you'll _end_ up with money (`$`).\n\nTo force a match to a complete string, anchor it with both `^` and `$`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(\"apple pie\", \"apple\", \"apple cake\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_detect(x, \"apple\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\nstr_detect(x, \"^apple$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] FALSE  TRUE FALSE\n```\n:::\n:::\n\n\nIn the second example above, 1 & 3 are `FALSE` because there's a space after `apple`.\n\n## Replacing matched pattern with another string\n\n`str_replace()` and `str_replace_all()` allow you to replace matches with new strings. The simplest use is to replace a pattern with a fixed string:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(\"apple\", \"pear\", \"banana\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_replace(x, \"a\", \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"-pple\"  \"pe-r\"   \"b-nana\"\n```\n:::\n\n```{.r .cell-code}\nstr_replace_all(x, \"a\", \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"-pple\"  \"pe-r\"   \"b-n-n-\"\n```\n:::\n:::\n\n\n# `stringr` functions work on vectors\n\nIn many of the above examples, we used a single string, but most `stringr` functions are designed to work on vectors of strings. For example, consider a vector of two \"fruit\":\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(\"apples\", \"oranges\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"apples\"  \"oranges\"\n```\n:::\n:::\n\n\nGet the first 3 letters in each string in `x`:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_sub(x, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"app\" \"ora\"\n```\n:::\n:::\n\n\nDuplicate each string in `x` twice:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_dup(x, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"applesapples\"   \"orangesoranges\"\n```\n:::\n:::\n\n\nConvert all strings in `x` to upper case:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_to_upper(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"APPLES\"  \"ORANGES\"\n```\n:::\n:::\n\n\nReplace all `\"a\"` characters with a `\"-\"` character:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_replace_all(x, \"a\", \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"-pples\"  \"or-nges\"\n```\n:::\n:::\n\n\n# Tips\n\n## Breaking a string into characters\n\nOften times you'll want to break a string into it's individual character components. To do that, use `str_split()` with the empty string `\"\"` as the delimiter:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nchars <- str_split(\"apples\", \"\")[[1]]\nchars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] \"a\" \"p\" \"p\" \"l\" \"e\" \"s\"\n```\n:::\n:::\n\n\n## Breaking a sentence into words\n\nSimilarly, if you have a single string that contains words separated by spaces, splitting on `\" \"` will break it into words:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- \"If you want to view paradise, simply look around and view it\"\nstr_split(x, \" \")[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  [1] \"If\"        \"you\"       \"want\"      \"to\"        \"view\"      \"paradise,\"\n#>  [7] \"simply\"    \"look\"      \"around\"    \"and\"       \"view\"      \"it\"\n```\n:::\n:::\n\n\n## Comparing strings\n\nIf you want to compare whether two strings are the same, you must also consider their cases. For example:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\na <- \"Apples\"\nb <- \"apples\"\na == b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] FALSE\n```\n:::\n:::\n\n\nThe above returns `FALSE` because the cases are different on the `\"a\"` characters. If you want to ignore case, then a common strategy is to first convert the strings to a common case before comparing. For example:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_to_lower(a) == str_to_lower(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> [1] TRUE\n```\n:::\n:::\n\n\n---\n\n**Page sources**:\n\nSome content on this page has been modified from other courses, including:\n\n- [R for Data Science](https://r4ds.had.co.nz/strings.html), by Garrett Grolemund & Hadley Wickham\n- [Handling Strings with R](https://www.gastonsanchez.com/r4strings/), by Gaston Sanchez\n- [Introduction to `stringr` vignette](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}